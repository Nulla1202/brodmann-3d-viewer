<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brodmann Areas 3D Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: white;
        }

        #main-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        #sidebar {
            width: 420px;
            background: rgba(30, 30, 50, 0.95);
            border-right: 2px solid rgba(100, 100, 150, 0.3);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        #sidebar h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #88ccff;
        }

        #sidebar .subtitle {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 20px;
        }

        #region-info {
            flex: 1;
        }

        #region-info.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            font-size: 18px;
            color: #66aaff;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(100, 100, 150, 0.3);
            padding-bottom: 5px;
        }

        .info-section p, .info-section ul {
            font-size: 14px;
            line-height: 1.6;
            color: #ddd;
        }

        .info-section ul {
            list-style: none;
            padding-left: 0;
        }

        .info-section li {
            padding: 5px 0;
            border-bottom: 1px solid rgba(100, 100, 150, 0.1);
        }

        .info-section li:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #88ccff;
            font-weight: bold;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loading {
            color: #88ccff;
            font-style: italic;
        }

        .error {
            color: #ff6666;
            padding: 10px;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="sidebar">
            <h1>Brodmann Areas</h1>
            <div class="subtitle">Click on a brain region to view details</div>
            <div id="region-info" class="empty">
                Select a region to view information
            </div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const canvasContainer = document.getElementById('canvas-container');
    const regionInfoDiv = document.getElementById('region-info');

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    canvasContainer.appendChild(renderer.domElement);
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // Add multiple lights to ensure visibility
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(50, 50, 50);
    scene.add(dirLight);
    const camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth/canvasContainer.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 150);
    const controls = new OrbitControls(camera, renderer.domElement);

    // Test cube to verify renderer is working
    const testCube = new THREE.Mesh(
      new THREE.BoxGeometry(20, 20, 20),
      new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
    );
    testCube.position.set(0, 0, 0);
    scene.add(testCube);

    // Axes helper in top-right corner
    const axesScene = new THREE.Scene();
    const axesCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
    axesCamera.position.set(0, 0, 2);
    const axesHelper = new THREE.AxesHelper(1);
    axesScene.add(axesHelper);

    // Load region data from JSON file
    async function loadRegionData(regionName) {
      try {
        regionInfoDiv.innerHTML = '<div class="loading">Loading...</div>';
        const response = await fetch(`./data/regions/${regionName}.json`);

        if (!response.ok) {
          throw new Error(`Region data not found for ${regionName}`);
        }

        const data = await response.json();
        displayRegionInfo(data);
      } catch (error) {
        console.error('Error loading region data:', error);
        regionInfoDiv.innerHTML = `
          <div class="error">
            <strong>Data not available</strong><br>
            Region: ${regionName}<br>
            <small>${error.message}</small>
          </div>
        `;
      }
    }

    // Display region information in sidebar
    function displayRegionInfo(data) {
      regionInfoDiv.className = '';

      // Generate Band Pass section HTML if available
      let bandPassHTML = '';
      if (data.band_pass_characteristics) {
        const bands = data.band_pass_characteristics;
        bandPassHTML = `
          <div class="info-section">
            <h3>EEG Band Pass Characteristics</h3>
            ${Object.keys(bands).map(bandName => {
              const band = bands[bandName];
              const bandLabel = bandName.charAt(0).toUpperCase() + bandName.slice(1);
              return `
                <div style="margin-bottom: 12px;">
                  <strong style="color: #88ccff;">${bandLabel} (${band.frequency_range})</strong>
                  <p style="font-size: 12px; color: #999; margin: 2px 0;">${band.description}</p>
                  <p style="font-size: 13px; margin: 4px 0;">${band.characteristics}</p>
                </div>
              `;
            }).join('')}
          </div>
        `;
      }

      regionInfoDiv.innerHTML = `
        <div class="info-section">
          <h3>${data.name}</h3>
          <p>${data.description}</p>
        </div>

        <div class="info-section">
          <p><span class="info-label">BA Label:</span> ${data.ba_label || 'N/A'}</p>
          <p><span class="info-label">Location:</span> ${data.location}</p>
          <p><span class="info-label">Hemisphere:</span> ${data.hemisphere || 'N/A'}</p>
          <p><span class="info-label">Vertices:</span> ${data.vertices}</p>
        </div>

        <div class="info-section">
          <h3>Function</h3>
          <p>${data.function}</p>
        </div>

        ${bandPassHTML}

        <div class="info-section">
          <h3>Connections</h3>
          <ul>
            ${data.connections ? data.connections.map(conn => `<li>â†’ ${conn}</li>`).join('') : '<li>No data available</li>'}
          </ul>
        </div>

        ${data.connectivity_pattern ? `
        <div class="info-section">
          <h3>Connectivity Pattern</h3>
          <p>${data.connectivity_pattern}</p>
        </div>
        ` : ''}

        <div class="info-section">
          <h3>Clinical Significance</h3>
          <p>${data.clinical_significance}</p>
        </div>
      `;
    }

    // Load GLB model
    const loader = new GLTFLoader();
    const parts = [];
    loader.load('./BA_v2.glb', (gltf)=>{
      scene.add(gltf.scene);
      console.log('=== GLB Structure ===');

      // Compute bounding box for auto-fitting camera
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      console.log(`Bounding box - Center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), Size: (${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)})`);

      // Position camera to fit the model
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.5; // Add some margin
      camera.position.set(center.x, center.y, center.z + cameraZ);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();

      gltf.scene.traverse(o=>{
        if (o.isMesh) {
          console.log(`Type: ${o.type}, Name: "${o.name}", Vertices: ${o.geometry?.attributes?.position?.count}, Color: ${o.material?.color?.getHexString()}`);

          // Make material double-sided and ensure it's visible
          if (o.material) {
            o.material.side = THREE.DoubleSide;
            o.material.needsUpdate = true;
          }

          // All meshes are clickable targets
          o.userData.basePos = o.position.clone();
          o.userData.lift = 0; o.userData.liftTarget = 0; o.userData.locked = false;
          // Store original color for brightening effect
          if (o.material && o.material.color) {
            o.userData.baseColor = o.material.color.clone();
          }
          parts.push(o);
        }
      });
      console.log(`Total: ${parts.length} mesh objects found`);
      console.log(`Camera position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`);
      console.log(`Camera looking at: (${controls.target.x.toFixed(2)}, ${controls.target.y.toFixed(2)}, ${controls.target.z.toFixed(2)})`);
    });

    const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let hover = null;
    let selectedRegion = null; // Currently selected region (exclusive selection)
    // TODO: For future multi-selection mode, change this to: let selectedRegions = new Set();

    addEventListener('pointermove', (e)=>{
      const rect = canvasContainer.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const hit = ray.intersectObjects(parts, false)[0]?.object || null;
      if (hover!==hit) {
        if (hover && !hover.userData.locked) hover.userData.liftTarget = 0;
        hover = hit;
        if (hover && !hover.userData.locked) hover.userData.liftTarget = 1;
        renderer.domElement.style.cursor = hover ? 'pointer' : 'default';
      }
    });

    addEventListener('click', (e)=>{
      // Check if click is on canvas
      const rect = canvasContainer.getBoundingClientRect();
      if (e.clientX < rect.left || e.clientX > rect.right ||
          e.clientY < rect.top || e.clientY > rect.bottom) {
        return;
      }

      if (!hover) return;

      // EXCLUSIVE SELECTION MODE: Only one region can be selected at a time
      // Deselect previously selected region
      if (selectedRegion && selectedRegion !== hover) {
        selectedRegion.userData.locked = false;
        selectedRegion.userData.liftTarget = 0;

        // Restore original color of previously selected region
        if (selectedRegion.material && selectedRegion.material.color && selectedRegion.userData.baseColor) {
          selectedRegion.material.color.copy(selectedRegion.userData.baseColor);
        }
      }

      // Toggle selection of current region
      const wasLocked = hover.userData.locked;
      hover.userData.locked = !wasLocked;
      hover.userData.liftTarget = hover.userData.locked ? 1 : 0;

      // Update selectedRegion
      selectedRegion = hover.userData.locked ? hover : null;

      // Click: brighten/restore color
      if (hover.material && hover.material.color && hover.userData.baseColor) {
        if (hover.userData.locked) {
          // Brighten by converting to HSL and increasing lightness
          const hsl = {};
          hover.userData.baseColor.getHSL(hsl);
          hover.material.color.setHSL(hsl.h, hsl.s, Math.min(hsl.l + 0.3, 1.0));

          // Load region data
          loadRegionData(hover.name);
        } else {
          // Restore original color
          hover.material.color.copy(hover.userData.baseColor);
        }
      }

      // TODO: For future multi-selection mode with relationship analysis:
      // 1. Change to: selectedRegions.add(hover) or selectedRegions.delete(hover)
      // 2. When selectedRegions.size > 1, call analyzeRelationships(selectedRegions)
      // 3. Display relationship analysis in sidebar (shared functions, connectivity patterns, etc.)
    });

    function animate(){
      requestAnimationFrame(animate);
      // hover/locked: lift upward (Y-axis) and scale slightly
      for (const m of parts) {
        m.userData.lift += (m.userData.liftTarget - m.userData.lift)*0.15;
        // Move upward (Y-axis) when lifted
        const offset = new THREE.Vector3(0, 15 * m.userData.lift, 0);
        m.position.copy(m.userData.basePos).add(offset);
        const s = 1 + 0.1*m.userData.lift;
        m.scale.setScalar(s);
      }

      const width = canvasContainer.clientWidth;
      const height = canvasContainer.clientHeight;

      // Render main scene
      renderer.setScissorTest(false);
      renderer.setViewport(0, 0, width, height);
      renderer.render(scene, camera);

      // Render axes in top-right corner
      axesCamera.quaternion.copy(camera.quaternion);
      const axesSize = 100;
      renderer.clearDepth();
      renderer.setScissorTest(true);
      renderer.setScissor(width - axesSize - 10, height - axesSize - 10, axesSize, axesSize);
      renderer.setViewport(width - axesSize - 10, height - axesSize - 10, axesSize, axesSize);
      renderer.render(axesScene, axesCamera);

      // Reset viewport
      renderer.setScissorTest(false);
      renderer.setViewport(0, 0, width, height);
    }
    animate();

    // Window resize handling
    addEventListener('resize', ()=>{
      const width = canvasContainer.clientWidth;
      const height = canvasContainer.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
    </script>
</body>
</html>
