<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brodmann Areas 3D Viewer</title>
    <style>
        :root {
            --bg-1: #f7f7ff;
            --bg-2: #e7f3ff;
            --panel: #ffffff;
            --panel-strong: #f1f4ff;
            --text: #2f3a4a;
            --muted: #708198;
            --accent: #7c9cf5;
            --accent-2: #f7a9c4;
            --border: #dfe7f5;
            --shadow: 0 20px 60px rgba(51, 86, 145, 0.14);
            --radius: 18px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Noto Sans JP', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: radial-gradient(circle at 20% 20%, #fef6ff, var(--bg-1)), linear-gradient(160deg, var(--bg-1), var(--bg-2));
            color: var(--text);
        }

        #main-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            gap: 12px;
            padding: 16px;
        }

        #sidebar {
            width: 430px;
            min-width: 360px;
            max-width: 480px;
            background: rgba(255, 255, 255, 0.82);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow-y: auto;
            padding: 20px 22px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(145deg, #f5f8ff, #fdf7ff);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .titles {
            flex: 1;
        }

        .eyebrow {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 4px;
        }

        #title-text {
            font-size: 26px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 4px;
        }

        #subtitle-text {
            font-size: 13px;
            color: var(--muted);
        }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: linear-gradient(120deg, #ffe3f0, #e1e9ff);
            color: #6c3c7a;
            font-weight: 600;
            font-size: 12px;
            border: 1px solid #f3d8e8;
            box-shadow: 0 10px 30px rgba(255, 170, 206, 0.25);
            width: fit-content;
        }

        button {
            cursor: pointer;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
            font-size: 13px;
        }

        button:active {
            transform: translateY(1px);
        }

        .ghost-btn {
            padding: 10px 12px;
            background: #f3f6ff;
            color: var(--text);
            border: 1px solid var(--border);
            box-shadow: inset 0 1px 0 #fff;
        }

        .ghost-btn:hover {
            background: #e7edff;
        }

        .primary-btn {
            padding: 10px 12px;
            background: linear-gradient(135deg, var(--accent), #9fb9ff);
            color: #fff;
            box-shadow: 0 12px 30px rgba(124, 156, 245, 0.35);
        }

        .primary-btn:hover {
            background: linear-gradient(135deg, #6f8ae8, #8eb0ff);
        }

        #region-info {
            flex: 1;
        }

        #region-info.empty {
            min-height: 240px;
            display: grid;
            place-items: center;
            color: var(--muted);
            font-style: italic;
            border: 1px dashed var(--border);
            border-radius: var(--radius);
            background: #f9fbff;
        }

        .info-section {
            margin-bottom: 18px;
            background: #ffffff;
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 14px;
            box-shadow: 0 8px 24px rgba(60, 98, 180, 0.06);
        }

        .info-section h3 {
            font-size: 16px;
            color: var(--text);
            margin-bottom: 6px;
        }

        .info-section p, .info-section ul {
            font-size: 14px;
            line-height: 1.7;
            color: var(--muted);
        }

        .info-section ul {
            list-style: none;
            padding-left: 0;
        }

        .info-section li {
            padding: 6px 0;
            border-bottom: 1px solid #eef2fb;
        }

        .info-section li:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--accent);
            font-weight: 700;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 6px;
        }

        .meta-item {
            padding: 10px 12px;
            border-radius: 12px;
            background: #f6f8ff;
            border: 1px solid var(--border);
            color: var(--text);
            font-weight: 600;
            box-shadow: inset 0 1px 0 #fff;
        }

        .hint {
            font-size: 13px;
            color: var(--muted);
            background: #f7f9ff;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: 0 6px 16px rgba(80, 120, 200, 0.08);
        }

        .loading {
            color: var(--accent);
            font-style: italic;
        }

        .error {
            color: #c7566d;
            padding: 12px;
            background: #fff1f4;
            border: 1px solid #ffd7df;
            border-radius: 10px;
        }

        #status-chip {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border);
            border-radius: 999px;
            padding: 10px 12px;
            color: var(--text);
            font-weight: 600;
            box-shadow: var(--shadow);
            z-index: 2;
            pointer-events: none;
            user-select: none;
        }

        @media (max-width: 1024px) {
            #main-container {
                flex-direction: column;
            }

            #sidebar {
                width: 100%;
                max-width: 100%;
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div id="main-container">
        <aside id="sidebar">
            <div class="header">
                <div class="titles">
                    <div class="eyebrow">Neuro Atlas</div>
                    <h1 id="title-text">Brodmann Areas</h1>
                    <div id="subtitle-text" class="subtitle">Click on a brain region to view details</div>
                </div>
                <div class="actions">
                    <button id="reset-view-btn" class="ghost-btn" type="button">Reset view</button>
                    <button id="language-toggle" class="primary-btn" type="button" aria-label="Toggle language">日本語</button>
                </div>
            </div>
            <div id="hint-text" class="hint">Drag to rotate • Scroll to zoom • Click to inspect</div>
            <div id="region-info" class="empty">
                Select a region to view information
            </div>
        </aside>
        <div id="canvas-container">
            <div id="status-chip">Interactive 3D · Pastel mode</div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const canvasContainer = document.getElementById('canvas-container');
    const regionInfoDiv = document.getElementById('region-info');
    const languageToggle = document.getElementById('language-toggle');
    const resetViewBtn = document.getElementById('reset-view-btn');
    const titleTextEl = document.getElementById('title-text');
    const subtitleTextEl = document.getElementById('subtitle-text');
    const hintTextEl = document.getElementById('hint-text');
    const statusChip = document.getElementById('status-chip');

    const translations = {
      en: {
        title: 'Brodmann Areas',
        subtitle: 'Click on a brain region to view details',
        hint: 'Drag to rotate • Scroll to zoom • Click to inspect',
        status: 'Interactive 3D · Pastel mode',
        selectPrompt: 'Select a region to view information',
        loading: 'Loading...',
        dataUnavailable: 'Data not available',
        region: 'Region',
        baLabel: 'BA Label',
        location: 'Location',
        hemisphere: 'Hemisphere',
        vertices: 'Vertices',
        function: 'Function',
        connections: 'Connections',
        connectivity: 'Connectivity Pattern',
        clinical: 'Clinical Significance',
        eeg: 'EEG Band Pass Characteristics',
        noData: 'No data available',
        langToggle: '日本語',
        langAria: 'Switch to Japanese',
        reset: 'Reset view'
      },
      ja: {
        title: 'ブロードマン領域',
        subtitle: '脳の領域をクリックすると詳細が表示されます',
        hint: 'ドラッグで回転・スクロールでズーム・クリックで詳細',
        status: 'インタラクティブ3D · パステルモード',
        selectPrompt: '領域を選択してください',
        loading: '読み込み中...',
        dataUnavailable: 'データがありません',
        region: '領域',
        baLabel: 'BAラベル',
        location: '位置',
        hemisphere: '半球',
        vertices: '頂点数',
        function: '機能',
        connections: '接続',
        connectivity: '結合パターン',
        clinical: '臨床的意義',
        eeg: 'EEG バンド特性',
        noData: 'データがありません',
        langToggle: 'English',
        langAria: '英語に切替',
        reset: 'ビューをリセット'
      }
    };

    const bandLabels = {
      delta: { en: 'Delta', ja: 'デルタ' },
      theta: { en: 'Theta', ja: 'シータ' },
      alpha: { en: 'Alpha', ja: 'アルファ' },
      beta: { en: 'Beta', ja: 'ベータ' },
      gamma: { en: 'Gamma', ja: 'ガンマ' }
    };

    let currentLang = (localStorage.getItem('lang') || (navigator.language?.startsWith('ja') ? 'ja' : 'en'));
    let lastRegionData = null;
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.inset = '0';
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.pointerEvents = 'auto';
    renderer.domElement.style.zIndex = '0';
    canvasContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f7fb);

    // Softer lights for pastel tone
    // Slightly brighter, soft multi-source lighting to lift model visibility
    scene.add(new THREE.AmbientLight(0xffffff, 1.05));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(60, 80, 70);
    scene.add(dirLight);
    const hemiLight = new THREE.HemisphereLight(0xf0f6ff, 0xfaf1ff, 0.35);
    scene.add(hemiLight);

    const camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth/canvasContainer.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 150);
    const controls = new OrbitControls(camera, renderer.domElement);

    // Axes helper in top-right corner
    const axesScene = new THREE.Scene();
    const axesCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
    axesCamera.position.set(0, 0, 2);
    const axesHelper = new THREE.AxesHelper(1);
    axesScene.add(axesHelper);

    function t(key) {
      return translations[currentLang]?.[key] || translations.en[key] || key;
    }

    function pickLocalized(data, field) {
      const localized = data.translations?.[currentLang]?.[field];
      if (localized && typeof localized === 'string' && localized.trim().length) return localized;
      return data[field];
    }

    function renderEmptyState() {
      regionInfoDiv.className = 'empty';
      regionInfoDiv.innerHTML = t('selectPrompt');
    }

    function applyLanguage() {
      document.documentElement.lang = currentLang;
      titleTextEl.textContent = t('title');
      subtitleTextEl.textContent = t('subtitle');
      hintTextEl.textContent = t('hint');
      statusChip.textContent = t('status');
      languageToggle.textContent = t('langToggle');
      languageToggle.setAttribute('aria-label', t('langAria'));
      resetViewBtn.textContent = t('reset');
      if (lastRegionData) {
        displayRegionInfo(lastRegionData);
      } else {
        renderEmptyState();
      }
    }

    languageToggle.addEventListener('click', () => {
      currentLang = currentLang === 'en' ? 'ja' : 'en';
      localStorage.setItem('lang', currentLang);
      applyLanguage();
    });

    // Load region data from JSON file
    async function loadRegionData(regionName) {
      try {
        regionInfoDiv.className = '';
        regionInfoDiv.innerHTML = `<div class="loading">${t('loading')}</div>`;
        const response = await fetch(`./data/regions/${regionName}.json`);

        if (!response.ok) {
          throw new Error(`Region data not found for ${regionName}`);
        }

        const data = await response.json();
        lastRegionData = data;
        displayRegionInfo(data);
      } catch (error) {
        console.error('Error loading region data:', error);
        regionInfoDiv.innerHTML = `
          <div class="error">
            <strong>${t('dataUnavailable')}</strong><br>
            Region: ${regionName}<br>
            <small>${error.message}</small>
          </div>
        `;
      }
    }

    // Display region information in sidebar
    function displayRegionInfo(data) {
      regionInfoDiv.className = '';

      let bandPassHTML = '';
      if (data.band_pass_characteristics) {
        const bands = data.band_pass_characteristics;
        bandPassHTML = `
          <div class="info-section">
            <h3>${t('eeg')}</h3>
            ${Object.keys(bands).map(bandName => {
              const band = bands[bandName];
              const labelSet = bandLabels[bandName.toLowerCase()] || { en: bandName, ja: bandName };
              const bandLabel = labelSet[currentLang] || labelSet.en || bandName;
              return `
                <div style="margin-bottom: 12px;">
                  <strong style="color: var(--accent);">${bandLabel} (${band.frequency_range})</strong>
                  <p style="font-size: 12px; color: var(--muted); margin: 2px 0;">${band.description}</p>
                  <p style="font-size: 13px; margin: 4px 0;">${band.characteristics}</p>
                </div>
              `;
            }).join('')}
          </div>
        `;
      }

      const connectionsHTML = data.connections && data.connections.length
        ? data.connections.map(conn => `<li>→ ${conn}</li>`).join('')
        : `<li>${t('noData')}</li>`;

      const connectivityHTML = data.connectivity_pattern ? `
        <div class="info-section">
          <h3>${t('connectivity')}</h3>
          <p>${pickLocalized(data, 'connectivity_pattern')}</p>
        </div>
      ` : '';

      regionInfoDiv.innerHTML = `
        <div class="info-section">
          <h3>${pickLocalized(data, 'name')}</h3>
          <p>${pickLocalized(data, 'description')}</p>
        </div>

        <div class="info-section">
          <div class="meta-grid">
            <div class="meta-item">${t('baLabel')}: ${data.ba_label || 'N/A'}</div>
            <div class="meta-item">${t('location')}: ${pickLocalized(data, 'location')}</div>
            <div class="meta-item">${t('hemisphere')}: ${data.hemisphere || 'N/A'}</div>
            <div class="meta-item">${t('vertices')}: ${data.vertices}</div>
          </div>
        </div>

        <div class="info-section">
          <h3>${t('function')}</h3>
          <p>${pickLocalized(data, 'function')}</p>
        </div>

        ${bandPassHTML}

        <div class="info-section">
          <h3>${t('connections')}</h3>
          <ul>
            ${connectionsHTML}
          </ul>
        </div>

        ${connectivityHTML}

        <div class="info-section">
          <h3>${t('clinical')}</h3>
          <p>${pickLocalized(data, 'clinical_significance')}</p>
        </div>
      `;
    }

    // Load GLB model
    const loader = new GLTFLoader();
    const parts = [];
    let resetViewState = null;
    loader.load('./BA_v2.glb', (gltf)=>{
      scene.add(gltf.scene);

      // Compute bounding box for auto-fitting camera
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      // Position camera to fit the model
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.5; // Add some margin
      camera.position.set(center.x, center.y, center.z + cameraZ);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();
      resetViewState = {
        position: camera.position.clone(),
        target: controls.target.clone()
      };

      gltf.scene.traverse(o=>{
        if (o.isMesh) {
          // Make material double-sided and ensure it's visible
          if (o.material) {
            o.material.side = THREE.DoubleSide;
            o.material.needsUpdate = true;
            // Lift brightness slightly to counter a dark source model
            if (o.material.color) {
              o.material.color.multiplyScalar(1.25);
              o.material.color.r = Math.min(o.material.color.r, 1);
              o.material.color.g = Math.min(o.material.color.g, 1);
              o.material.color.b = Math.min(o.material.color.b, 1);
            }
          }

          o.userData.basePos = o.position.clone();
          o.userData.lift = 0; o.userData.liftTarget = 0; o.userData.locked = false;
          if (o.material && o.material.color) {
            o.userData.baseColor = o.material.color.clone();
          }
          parts.push(o);
        }
      });
    });

    const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
    let hover = null;
    let selectedRegion = null; // Currently selected region (exclusive selection)

    // Use window-level listeners and measure the canvas container like the original working version
    addEventListener('pointermove', (e)=>{
      if (!parts.length) return;
      const rect = canvasContainer.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const hit = ray.intersectObjects(parts, false)[0]?.object || null;
      if (hover!==hit) {
        if (hover && !hover.userData.locked) hover.userData.liftTarget = 0;
        hover = hit;
        if (hover && !hover.userData.locked) hover.userData.liftTarget = 1;
        renderer.domElement.style.cursor = hover ? 'pointer' : 'default';
      }
    });

    addEventListener('click', (e)=>{
      if (!parts.length) return;
      const rect = canvasContainer.getBoundingClientRect();
      if (e.clientX < rect.left || e.clientX > rect.right ||
          e.clientY < rect.top || e.clientY > rect.bottom) {
        return;
      }

      if (!hover) return;

      if (selectedRegion && selectedRegion !== hover) {
        selectedRegion.userData.locked = false;
        selectedRegion.userData.liftTarget = 0;
        if (selectedRegion.material && selectedRegion.material.color && selectedRegion.userData.baseColor) {
          selectedRegion.material.color.copy(selectedRegion.userData.baseColor);
        }
      }

      const wasLocked = hover.userData.locked;
      hover.userData.locked = !wasLocked;
      hover.userData.liftTarget = hover.userData.locked ? 1 : 0;
      selectedRegion = hover.userData.locked ? hover : null;

      if (hover.material && hover.material.color && hover.userData.baseColor) {
        if (hover.userData.locked) {
          const hsl = {};
          hover.userData.baseColor.getHSL(hsl);
          hover.material.color.setHSL(hsl.h, hsl.s * 0.85, Math.min(hsl.l + 0.25, 1.0));
          loadRegionData(hover.name);
        } else {
          hover.material.color.copy(hover.userData.baseColor);
        }
      }
    });

    resetViewBtn.addEventListener('click', ()=>{
      if (!resetViewState) return;
      camera.position.copy(resetViewState.position);
      controls.target.copy(resetViewState.target);
      controls.update();
    });

    function animate(){
      requestAnimationFrame(animate);
      for (const m of parts) {
        m.userData.lift += (m.userData.liftTarget - m.userData.lift)*0.15;
        const offset = new THREE.Vector3(0, 15 * m.userData.lift, 0);
        m.position.copy(m.userData.basePos).add(offset);
        const s = 1 + 0.08*m.userData.lift;
        m.scale.setScalar(s);
      }

      const width = canvasContainer.clientWidth;
      const height = canvasContainer.clientHeight;

      renderer.setScissorTest(false);
      renderer.setViewport(0, 0, width, height);
      renderer.render(scene, camera);

      axesCamera.quaternion.copy(camera.quaternion);
      const axesSize = 100;
      renderer.clearDepth();
      renderer.setScissorTest(true);
      renderer.setScissor(width - axesSize - 10, height - axesSize - 10, axesSize, axesSize);
      renderer.setViewport(width - axesSize - 10, height - axesSize - 10, axesSize, axesSize);
      renderer.render(axesScene, axesCamera);

      renderer.setScissorTest(false);
      renderer.setViewport(0, 0, width, height);
    }
    animate();

    addEventListener('resize', ()=>{
      const width = canvasContainer.clientWidth;
      const height = canvasContainer.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });

    applyLanguage();
    </script>
</body>
</html>
